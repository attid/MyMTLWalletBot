{% extends "base.html" %}

{% block title %}Подписание транзакции{% endblock %}

{% block content %}
<div class="card" id="loading-card">
    <div class="spinner"></div>
    <p>Загрузка транзакции...</p>
</div>

<div class="card hidden" id="error-card">
    <div class="icon error-icon">!</div>
    <h2>Ошибка</h2>
    <p id="error-message"></p>
    <button class="btn btn-secondary" onclick="Telegram.WebApp.close()">Закрыть</button>
</div>

<div class="card hidden" id="tx-card">
    <h2>Подтвердите транзакцию</h2>

    <div class="tx-info">
        <div class="tx-memo" id="tx-memo"></div>
        <div class="tx-address">
            <span class="label">Кошелек:</span>
            <span class="value" id="tx-address"></span>
        </div>
    </div>

    <div class="divider"></div>

    <!-- Вариант 1: Есть сохраненный ключ -->
    <div id="sign-section" class="hidden">
        <p class="hint">Ключ сохранен в этом устройстве</p>
        <button class="btn btn-primary" id="btn-sign" onclick="signTransaction()">
            Подписать
        </button>
    </div>

    <!-- Вариант 2: Выбор ключа из сохраненных -->
    <div id="key-selector-section" class="hidden">
        <p class="hint">Выберите ключ для подписания или добавьте новый</p>
        <div id="saved-keys-list" class="key-list"></div>
        <button class="btn btn-primary" onclick="goToImport()">
            Добавить новый ключ
        </button>
        <button class="btn btn-secondary" onclick="showXdr()">
            Показать XDR
        </button>
    </div>

    <!-- Вариант 3: Нет сохраненных ключей -->
    <div id="no-key-section" class="hidden">
        <p class="hint">Ключ не найден на этом устройстве</p>
        <button class="btn btn-primary" id="btn-import" onclick="goToImport()">
            Добавить ключ
        </button>
        <button class="btn btn-secondary" id="btn-show-xdr" onclick="showXdr()">
            Показать XDR
        </button>
    </div>

    <!-- XDR для копирования -->
    <div id="xdr-section" class="hidden">
        <p class="hint">Скопируйте XDR и подпишите вручную:</p>
        <textarea class="xdr-text" id="xdr-text" readonly></textarea>
        <button class="btn btn-secondary" onclick="copyXdr()">
            Копировать XDR
        </button>
    </div>
</div>

<div class="card hidden" id="success-card">
    <div class="icon success-icon">&#10003;</div>
    <h2>Транзакция подписана</h2>
    <p>Транзакция отправлена на обработку</p>
</div>
{% endblock %}

{% block scripts %}
<script>
const TX_ID = "{{ tx_id }}";
let txData = null;
let selectedSignerAddress = null;

// Initialize Telegram WebApp
const tg = Telegram.WebApp;
tg.ready();
tg.expand();

// Auth header for API requests
const AUTH_HEADERS = {
    "X-Telegram-Init-Data": tg.initData || ""
};

// Apply Telegram theme
document.body.style.backgroundColor = tg.themeParams.bg_color || '#fff';
document.body.style.color = tg.themeParams.text_color || '#000';

async function init() {
    if (!TX_ID) {
        showError("ID транзакции не указан");
        return;
    }

    try {
        const response = await fetch(`/api/tx/${TX_ID}`, {
            headers: AUTH_HEADERS
        });
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || "Транзакция не найдена");
        }

        txData = await response.json();

        if (txData.status !== "pending") {
            showError(`Транзакция уже ${txData.status === 'signed' ? 'подписана' : 'обработана'}`);
            return;
        }

        // Display TX info
        document.getElementById("tx-memo").textContent = txData.memo;
        document.getElementById("tx-address").textContent = formatAddress(txData.wallet_address);
        document.getElementById("xdr-text").value = txData.unsigned_xdr;

        hideElement("loading-card");
        showElement("tx-card");

        // Check for saved signer mapping
        const signerAddress = CryptoStorage.getWalletSigner(txData.wallet_address);

        if (signerAddress) {
            // Have mapping, check if key still exists
            const hasKey = await CryptoStorage.hasKey(signerAddress);
            if (hasKey) {
                selectedSignerAddress = signerAddress;
                showElement("sign-section");
                return;
            }
            // Key was deleted, remove stale mapping
            CryptoStorage.removeWalletSigner(txData.wallet_address);
        }

        // No mapping - show key selector or no-key section
        const savedKeys = await CryptoStorage.listAddresses();

        if (savedKeys.length > 0) {
            showKeySelector(savedKeys);
        } else {
            showElement("no-key-section");
        }

    } catch (error) {
        showError(error.message);
    }
}

function showKeySelector(keys) {
    const listEl = document.getElementById("saved-keys-list");
    listEl.innerHTML = "";

    for (const addr of keys) {
        const item = document.createElement("div");
        item.className = "key-item";
        item.innerHTML = `
            <span class="key-address">${formatAddress(addr)}</span>
            <button class="btn-select" onclick="selectKey('${addr}')">Выбрать</button>
        `;
        listEl.appendChild(item);
    }

    showElement("key-selector-section");
}

async function selectKey(signerAddress) {
    selectedSignerAddress = signerAddress;
    hideElement("key-selector-section");
    showElement("sign-section");
}

async function signTransaction() {
    const btn = document.getElementById("btn-sign");
    btn.disabled = true;
    btn.textContent = "Подписание...";

    try {
        // Get secret key from storage using signer address
        const signerAddress = selectedSignerAddress || txData.wallet_address;
        const secretKey = await CryptoStorage.getKey(signerAddress);
        if (!secretKey) {
            throw new Error("Ключ не найден");
        }

        // Sign XDR
        const keypair = StellarSdk.Keypair.fromSecret(secretKey);
        const transaction = new StellarSdk.Transaction(
            txData.unsigned_xdr,
            StellarSdk.Networks.PUBLIC
        );
        transaction.sign(keypair);
        const signedXdr = transaction.toXDR();

        // Submit signed XDR
        const response = await fetch(`/api/tx/${TX_ID}/sign`, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                ...AUTH_HEADERS
            },
            body: JSON.stringify({ signed_xdr: signedXdr }),
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.detail || "Ошибка отправки");
        }

        // Save wallet → signer mapping for future transactions
        CryptoStorage.setWalletSigner(txData.wallet_address, signerAddress);

        // Show success
        hideElement("tx-card");
        showElement("success-card");

        // Close WebApp after delay
        setTimeout(() => {
            tg.close();
        }, 2000);

    } catch (error) {
        showToast(error.message, "error");
        btn.disabled = false;
        btn.textContent = "Подписать";
    }
}

function goToImport() {
    window.location.href = `/import?address=${txData.wallet_address}&return_tx=${TX_ID}`;
}

function showXdr() {
    hideElement("no-key-section");
    hideElement("key-selector-section");
    showElement("xdr-section");
}

function copyXdr() {
    const xdrText = document.getElementById("xdr-text");
    xdrText.select();
    document.execCommand("copy");
    showToast("XDR скопирован");
}

// Helpers
function formatAddress(addr) {
    if (!addr || addr.length < 12) return addr;
    return addr.substring(0, 6) + "..." + addr.substring(addr.length - 6);
}

function showElement(id) {
    document.getElementById(id).classList.remove("hidden");
}

function hideElement(id) {
    document.getElementById(id).classList.add("hidden");
}

function showError(message) {
    document.getElementById("error-message").textContent = message;
    hideElement("loading-card");
    hideElement("tx-card");
    showElement("error-card");
}

function showToast(message, type = "info") {
    const toast = document.getElementById("toast");
    toast.textContent = message;
    toast.className = `toast show ${type}`;
    setTimeout(() => {
        toast.className = "toast";
    }, 3000);
}

// Start
init();
</script>
{% endblock %}
