{% extends "base.html" %}

{% block title %}Добавить ключ{% endblock %}

{% block content %}
<div class="card" id="import-card">
    <h2>Добавить ключ</h2>

    <div class="tx-address">
        <span class="label">Кошелек:</span>
        <span class="value" id="wallet-address"></span>
    </div>

    <div class="divider"></div>

    <p class="hint">
        Введите секретный ключ (начинается с S).
        Ключ будет зашифрован и сохранен только на этом устройстве.
    </p>

    <div class="form-group">
        <label for="secret-key">Секретный ключ</label>
        <input
            type="password"
            id="secret-key"
            class="input"
            placeholder="SXXXX..."
            autocomplete="off"
            autocapitalize="characters"
        >
        <button type="button" class="btn-toggle-visibility" onclick="toggleKeyVisibility()">
            <span id="visibility-icon">&#128065;</span>
        </button>
    </div>

    <!-- Mode selection -->
    <div class="form-group" id="mode-section">
        <label>Способ защиты ключа:</label>
        <div class="mode-options">
            <label class="mode-option" id="mode-biometric-option">
                <input type="radio" name="storage-mode" value="biometric" id="mode-biometric">
                <span class="mode-label">Биометрия</span>
                <span class="mode-desc">Face ID / Touch ID / Отпечаток</span>
            </label>
            <label class="mode-option">
                <input type="radio" name="storage-mode" value="password" id="mode-password">
                <span class="mode-label">Пароль</span>
                <span class="mode-desc">Защита паролем</span>
            </label>
        </div>
    </div>

    <!-- Password fields (shown when password mode selected) -->
    <div class="form-group hidden" id="password-section">
        <label for="password">Пароль</label>
        <input
            type="password"
            id="password"
            class="input"
            placeholder="Введите пароль"
            autocomplete="new-password"
            oninput="checkKeyboardLayout()"
        >
        <label for="password-confirm" style="margin-top: 12px">Подтверждение пароля</label>
        <input
            type="password"
            id="password-confirm"
            class="input"
            placeholder="Повторите пароль"
            autocomplete="new-password"
            oninput="checkKeyboardLayout()"
        >
        <div id="layout-warning" class="layout-warning hidden">
            ⚠️ Включена русская раскладка
        </div>
    </div>

    <div class="form-group">
        <label>
            <input type="checkbox" id="confirm-checkbox">
            Я понимаю, что ключ будет сохранен в браузере этого устройства
        </label>
    </div>

    <button class="btn btn-primary" id="btn-save" onclick="saveKey()" disabled>
        Сохранить ключ
    </button>

    <button class="btn btn-secondary" onclick="cancel()">
        Отмена
    </button>
</div>

<div class="card hidden" id="success-card">
    <div class="icon success-icon">&#10003;</div>
    <h2>Ключ сохранен</h2>
    <p>Адрес: <span id="saved-address" class="value"></span></p>
    <p>Теперь вы можете подписывать транзакции</p>
</div>

<div class="card hidden" id="error-card">
    <div class="icon error-icon">!</div>
    <h2>Ошибка</h2>
    <p id="error-message"></p>
    <button class="btn btn-secondary" onclick="location.reload()">Попробовать снова</button>
</div>
{% endblock %}

{% block scripts %}
<script>
const WALLET_ADDRESS = "{{ wallet_address }}";
const RETURN_TX = new URLSearchParams(window.location.search).get("return_tx");

// Initialize Telegram WebApp
const tg = Telegram.WebApp;
tg.ready();
tg.expand();

// Apply Telegram theme
document.body.style.backgroundColor = tg.themeParams.bg_color || '#fff';
document.body.style.color = tg.themeParams.text_color || '#000';

let biometricAvailable = false;

async function init() {
    if (!WALLET_ADDRESS) {
        showError("Адрес кошелька не указан");
        return;
    }

    document.getElementById("wallet-address").textContent = formatAddress(WALLET_ADDRESS);

    // Check biometric availability
    biometricAvailable = await BiometricStorage.isAvailable();
    setupModeSelection();

    // Enable save button when checkbox is checked
    const checkbox = document.getElementById("confirm-checkbox");
    const saveBtn = document.getElementById("btn-save");

    checkbox.addEventListener("change", () => {
        saveBtn.disabled = !checkbox.checked;
    });

    // Validate key on input
    const keyInput = document.getElementById("secret-key");
    keyInput.addEventListener("input", () => {
        keyInput.value = keyInput.value.toUpperCase();
    });
}

function setupModeSelection() {
    const biometricOption = document.getElementById("mode-biometric-option");
    const biometricRadio = document.getElementById("mode-biometric");
    const passwordRadio = document.getElementById("mode-password");
    const passwordSection = document.getElementById("password-section");

    if (!biometricAvailable) {
        // Hide biometric option if not available
        biometricOption.style.display = "none";
        passwordRadio.checked = true;
        showElement("password-section");
    } else {
        // Default to biometric if available
        biometricRadio.checked = true;
    }

    // Toggle password fields based on mode selection
    document.querySelectorAll('input[name="storage-mode"]').forEach(radio => {
        radio.addEventListener("change", () => {
            if (passwordRadio.checked) {
                showElement("password-section");
            } else {
                hideElement("password-section");
            }
        });
    });
}

function toggleKeyVisibility() {
    const input = document.getElementById("secret-key");
    const icon = document.getElementById("visibility-icon");

    if (input.type === "password") {
        input.type = "text";
        icon.innerHTML = "&#128064;"; // closed eye
    } else {
        input.type = "password";
        icon.innerHTML = "&#128065;"; // open eye
    }
}

async function saveKey() {
    const secretKey = document.getElementById("secret-key").value.trim();
    const btn = document.getElementById("btn-save");
    const mode = document.querySelector('input[name="storage-mode"]:checked')?.value;

    // Validate secret key format
    if (!secretKey.startsWith("S") || secretKey.length !== 56) {
        showToast("Неверный формат ключа", "error");
        return;
    }

    // Validate key and get public address
    let publicKey;
    try {
        const keypair = StellarSdk.Keypair.fromSecret(secretKey);
        publicKey = keypair.publicKey();

        if (publicKey !== WALLET_ADDRESS) {
            // Warn but don't block - user may be replacing a compromised key
            console.warn(`Key address ${publicKey} differs from expected ${WALLET_ADDRESS}`);
        }
    } catch (e) {
        showToast("Неверный секретный ключ", "error");
        return;
    }

    // Validate mode selection
    if (!mode) {
        showToast("Выберите способ защиты ключа", "error");
        return;
    }

    // Validate password if password mode
    if (mode === "password") {
        const password = document.getElementById("password").value;
        const passwordConfirm = document.getElementById("password-confirm").value;

        if (!password || password.length < 4) {
            showToast("Пароль должен быть минимум 4 символа", "error");
            return;
        }

        if (password !== passwordConfirm) {
            showToast("Пароли не совпадают", "error");
            return;
        }
    }

    btn.disabled = true;
    btn.textContent = "Сохранение...";

    try {
        if (mode === "biometric") {
            // Request biometric access first
            const granted = await BiometricStorage.requestAccess(
                "Для безопасного хранения ключа"
            );
            if (!granted) {
                throw new Error("Доступ к биометрии не предоставлен");
            }

            // Save key using biometric storage
            await CryptoStorage.saveKeyBiometric(publicKey, secretKey);
        } else {
            // Save key using password encryption
            const password = document.getElementById("password").value;
            await CryptoStorage.saveKeyPassword(publicKey, secretKey, password);
        }

        // Save wallet → signer mapping if wallet address was provided
        if (WALLET_ADDRESS) {
            CryptoStorage.setWalletSigner(WALLET_ADDRESS, publicKey);
        }

        // Show success with saved address
        document.getElementById("saved-address").textContent = formatAddress(publicKey);
        hideElement("import-card");
        showElement("success-card");

        // Return to sign page or close
        setTimeout(() => {
            if (RETURN_TX) {
                window.location.href = `/sign?tx=${RETURN_TX}`;
            } else {
                tg.close();
            }
        }, 1500);

    } catch (error) {
        showToast("Ошибка сохранения: " + error.message, "error");
        btn.disabled = false;
        btn.textContent = "Сохранить ключ";
    }
}

function cancel() {
    if (RETURN_TX) {
        window.location.href = `/sign?tx=${RETURN_TX}`;
    } else {
        tg.close();
    }
}

// Check for Cyrillic characters in password input
function checkKeyboardLayout() {
    const password = document.getElementById("password").value;
    const passwordConfirm = document.getElementById("password-confirm").value;
    const hasCyrillic = /[а-яёА-ЯЁ]/.test(password + passwordConfirm);
    const warning = document.getElementById("layout-warning");
    if (hasCyrillic) {
        warning.classList.remove("hidden");
    } else {
        warning.classList.add("hidden");
    }
}

// Helpers
function formatAddress(addr) {
    if (!addr || addr.length < 12) return addr;
    return addr.substring(0, 6) + "..." + addr.substring(addr.length - 6);
}

function showElement(id) {
    document.getElementById(id).classList.remove("hidden");
}

function hideElement(id) {
    document.getElementById(id).classList.add("hidden");
}

function showError(message) {
    document.getElementById("error-message").textContent = message;
    hideElement("import-card");
    showElement("error-card");
}

function showToast(message, type = "info") {
    const toast = document.getElementById("toast");
    toast.textContent = message;
    toast.className = `toast show ${type}`;
    setTimeout(() => {
        toast.className = "toast";
    }, 3000);
}

// Start
init();
</script>
{% endblock %}
